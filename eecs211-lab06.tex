\RequirePackage{fixltx2e}
\documentclass{tufte-handout}

\usepackage{eecs211-lab}

\title{EECS 211 Lab 6}
\author{Classes and Abstractation}
\date{Winter 2017}

\begin{document}

\maketitle

In this week's lab, we will be going over classes, encapsulation, and abstraction, and why both are important.

If you have any lingering questions during the lab, don't hesitate to ask your peer mentor!
\section{Getting the code}
Download the zip file from the course site: \medskip

\url{http://users.eecs.northwestern.edu/~jesse/course/eecs211/lab/eecs211-lab06.zip}

\medskip \noindent
After you have downloaded the zip file onto your laptop, extract the zip file into its own folder. Make sure you keep track of which folder it's in!  Next, open up CLion and Click on File --> Open Project, and click on the Lab 6 project that you just unzipped. 

Once you open the project, try building the lab and then running the lab6 executable. 
You should see some output printed in your output subwindow.
If you need a reminder on how to build and run code in CLion, consult lab 3/4 or ask your TA.
Once this works, you're ready to start the lab!

\section{Encapsulation and Abstraction}
You already have seen the idea of encapsulation and abstraction throughout the quarter.
One place that you see it is through structs.
When you create a struct, you are creating a type that encapsulates data members.
Another place you've created abstraction is through creating libraries, like linked\_lib or circle\_lib, which allow a consumer to use certain functions about circles or linked lists, and not have to see every little inner working under the hood.

\section{Classes}
So that brings us to classes.  
Classes allow you to create your own types, just like structs.
Additionally, with classes, we can create member functions, which allow you to do things that you may have already noticed from other classes, such as call myObject.area(); for instance.
This is similar to a data member, as the functions would work on the instances of the classes themselves.  
\subsection{Private vs Public}
One key difference between structs and classes is that struct data members and functions are public by default, but in classes, they are private by default.
But what does that mean?
Basically, public vs private determines what an instance of a class can access.\marginnote{We usually refer to instances of classes as \textit{objects}.}
First, examine a class with a definition something like this:
\begin{Code}
class Person {
private:
    std::string name_;
    int SSN_;
    double bank_balance_;
public:
    Person(std::string n, int s);
    Person(std::string n, int s, double b);
    bool canIBuyThis(double itemCost);
    bool canIBuyThis(int itemCost);
    double withdrawFromBank(double amount);

    std::string name();
    int SSN();
    double bank_balance();
};
\end{Code}
Notice here, that our Person class has a name\_, SSN\_, and bank\_balance\_ that are private. 
This means that if in our \functionname{main} or any other function creates an instance of a Person, it won't be able to access the Person's name\_, SSN\_ or bank\_balance.
For example, this code wouldn't work, as you can't access the SSN\_ or bank\_balance\_.
\begin{Code}
int main(){
    Person myPerson;
    cout << myPerson.name_ << '\n';
    cout << myPerson.SSN_ << '\n';
}
\end{Code}
However, what you CAN do, is create public functions that use the private data members or private functions.
Let's say a Person is at a store, and is trying to buy a soda pop.
While you don't want the register to be able to see how much money is on the Person's bank account, you still want to be able to tell whether or not the Person has enough money to purchase the soda pop.
So, you're able to run code something like this:
\begin{Code}
void buySoda(Person& p, double sodaPrice) {
    if (p.canIBuyThis(sodaPrice)) {
        p.withdrawFromBank(sodaPrice);
    }
    else {
        cout << "You don't have enough money!\n";
    }
}
\end{Code}
Notice, that we are able to compare the Person's bank\_balance\_ and the sodaPrice, without being able to look at the Person's bank\_balance\_, through the use of our public \functionname{canIBuyThis} function.
This allows us to abstract away the bank\_balance\_, while maintaining it's functionality!

\subsection{Constructors}
When you create an instance of a class, you use what's called a Constructor, which allows you to do something upon the creation of an object.
Typically, we'll use a constructor to set the private data members of your class.
For example, let's look at the definition of the constructor for Person.
\begin{Code}
Person::Person(string n, int s, double b) 
{
    name_ = n;
    SSN_ = s;
    bank_balance_ = b;
}
\end{Code}
Now, when you create a Person using the following syntax:
\begin{Code}
    Person myPerson {"Jesse", 1234567, 100.0};
\end{Code}

myPersons's name\_, SSN\_, and bank\_balance\_ are assigned to be Jesse, 1234567, and 100.0, respectively. 
Note that the following syntax would also be acceptable:
\begin{Code}
    Person myPerson = Person("Jesse", 1234567, 100.0);
\end{Code}

You probably noticed that this constructor allows for 3 parameters.
You can actually create different constructors for different numbers of parameters as inputs, allowing you to set default values easier, or do different things when a class is instantiated with a different number of arguments.
In \filename{Person.cpp}, we've defined another constructor for Person which only takes in 2 parameters:
\begin{Code}
Person::Person(string n, int s) 
{
    name_ = n;
    SSN_ = s;
    bank_balance_ = 0.0;
}
\end{Code}
This constructor will automatically assign bank\_balance\_ to be 0.0.
This is called \textit{\textbf{overloading}} a constructor.
When you call these constructors, C++ will call the correct constructor by looking at the number and type of the arguments it's given.

We can also overload functions! This works in the exact same way.
In \filename{Person.cpp}, note that \functionname{canIBuyThis} has 2 definitions. 
One of them takes in an int and the other takes in a double.
Each of these definitions behaves in a slightly different way.
Notice that both functions take in the same number of arguments but they are different types!
C++ looks at the parameter supplied and decides which function to call based on the type of that parameter.

\section{Practicing with classes}

To get a little practice with classes, implement the function \functionname{printPerson}. In order to do that, you'll need to implement the get functions\marginnote{The get functions are public functions that return the values of their respective private data members.} for the Person class in \filename{Person.cpp}.\marginnote{Hint: All 3 get functions can (and should) be implemented in one line.} Once you've done that, use the get functions in the \functionname{printPerson} function in order to print a string with the following format: \newline
\medskip
\noindent "This Person is named (name\_), has Social Security Number (SSN\_), 
and has (bank\_balance\_) dollars in their bank account." \newline
\medskip
\noindent For more practice, go \filename{Bank.cpp} and implement the function called \functionname{stealMoney}. Note that a Bank is another class that we've created for you.
A bank has a private vector of Person objects called accounts\_. It also has a public constructor and a get function for accounts\_ already implemented. 
Your job is to write the \functionname{stealMoney} function, which should iterate through each Person in accounts\_ and withdraw all of their money so that their bank\_balance\_ is 0. Add up all of the money you've stolen and return that value. The functions \functionname{bank\_balance} and \functionname{withdrawFromBank} in the Person class will be very helpful for this!

\end{document}