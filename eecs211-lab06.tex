\RequirePackage{fixltx2e}
\documentclass{tufte-handout}

\usepackage{eecs211-lab}

\title{EECS 211 Lab 6}
\author{Classes and Abstractation}
\date{Winter 2017}

\begin{document}

\maketitle

In this week's lab, we will be going over classes, ecanspulation, and abstraction, and why both are important.

If you have any lingering questions during the lab, don't hesitate to ask your peer mentor!
\section{Getting the code}
Download the zip file from the course site: \medskip

\url{http://users.eecs.northwestern.edu/~jesse/course/eecs211/lab/eecs211-lab06.zip}

\medskip \noindent
After you have downloaded the zip file onto your laptop, extract the zip file into its own folder. Make sure you keep track of which folder it's in!  Next, open up CLion and Click on File --> Open Project, and click on the Lab 6 project that you just unzipped. 

Once you open the project, try building the lab and then running the lab6 executable. 
You should see some output printed in your output subwindow.
If you need a reminder on how to build and run code in CLion, consult lab 3/4 or ask your TA.
Once this works, you're ready to start the lab!

\section{Encapsulation and Abstraction}
You already have seen the idea of encapsulation and abstraction throughout the quarter.
One place that you see it is through structs.
When you create a struct, you are creating a type that encapsulates data members.
Another place you've created abstraction is through creating libraries, like linked\_lib or circle\_lib, which allow a consumer to use certain functions about circles or linked lists, and not have to see every little inner working under the hood.

\section{Classes}
So that brings us to classes.  
Classes allow you to create your own types, just like structs.
Additionally, with classes, we can create member functions, which allow you to do things that you may have already noticed from other classes, such as call myObject.area(); for instance.
This is similar to a data member, as the functions would work on the instances of the classes themselves.  
\subsection{Private vs Public}
One key difference between structs and classes is that struct data members and functions are public by default, but in classes, they are private by default.
But what does that mean?
Basically, public vs private determines what an instance of a class can access.\marginnote{We usually refer to instances of classes as being called objects}
First, examine a class with a definition something like this:
\begin{Code}
class Dog{
    private: 
        int SSN;
        double bank_balance;
    public:
        bool canIBuyThis(double itemCost);
        bool hasValidSSN();
};
\end{Code}
Notice here, that our Dog class has both an SSN and a ban\_balance that are private. 
This means that if in our \functionname{main} or any other function creates an instance of a Dog, it won't be able to access the Dog's SSN or bank\_balance.
For example, this code wouldn't work, as you can't access the SSN or bank\_balance.
\begin{Code}
int main(){
    Dog doggy;
    cout<<doggy.SSN<<'\n';
    cout<<doggy.bank_balance<<'\n';
}
\end{Code}
However, what you CAN do, is create public functions that use the private data members or private functions.
Let's say a Dog is at a store, and is trying to buy a soda pop.
While you don't want the register to be able to see how much money is on the doggy's bank account, you still want to be able to tell whether or not the doggy has enough money to purchase the soda pop.
So, you're able to run code something like this:
\begin{Code}
void purchaseFunction(Dog& d, double sodaPrice){
    if (d.canIBuyThis(sodaPrice)){
        buySoda(d, sodaPrice);}
    else{
        // other stuff etc. }
}
\end{Code}
Notice, that we are able to compare the Dog's bank\_balance and the sodaPrice, without being able to look at the dog's bank\_balance, through the use of our public \functionname{canIBuyThis} function.
This allows us to abstract away the bank\_balance, while maintaining it's functionality!
You can imagine doing something similar with the SSN and \functionname{hasValidSSN()}
Cool, huh?

\subsection{Constructors}
When you create an instance of a class, you use what's called a Constructor, which allows you to do something on the creation of an object.
This "something" I just mentioned, is very typically used to set the fields of your class.
For example, look at the following definition and constructor:

\begin{Code}
    class Rectangle{
        private:
            double myWidth, myLength;
        public:
            Rectangle(double width, double length){
                myWidth = width;
                myLength = length;
            }
};
\end{Code}
Now, when you create a rectangle using the following syntax:
\begin{Code}
    Rectangle rect {5.2, 3.4};
\end{Code}
The rect's width and legnth are set to be 5.2 and 3.4

As you noticed, this constructor allows for 2 parameters.
You can actually create different constructors for different numbers of parameters as inputs, allowing you to set default values easier, or do different things when a class is instantiated with a different number of arguments.

\section{Practicing with classes}

//Code stuff goes here.


\end{document}