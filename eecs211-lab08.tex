\RequirePackage{fixltx2e}
\documentclass{tufte-handout}

\usepackage{eecs211-lab}

\title{EECS 211 Lab 8}
\author{Inheritance}
\date{Winter 2017}

\begin{document}

\maketitle

In this week's lab, we will be going over inheritance, and doing some more practice with classes.


If you have any lingering questions during the lab, don't hesitate to ask your peer mentor!
\section{Getting the code}
Download the zip file from the course site: \medskip

\url{http://users.eecs.northwestern.edu/~jesse/course/eecs211/lab/eecs211-lab08.zip}

\medskip \noindent
After you have downloaded the zip file onto your laptop, extract the zip file into its own folder. Make sure you keep track of which folder it's in!  Next, open up CLion and Click on File --> Open Project, and click on the Lab 8 project that you just unzipped. 

Once you open the project, try building the lab and then running the lab6 executable. 
You should see some output printed in your output subwindow.
If you need a reminder on how to build and run code in CLion, consult lab 3/4 or ask your TA.
Once this works, you're ready to start the lab!

\section{Inheritance}

\section {General Idea}
Inheritance is an incredibly important idea, central to object oriented design.
The main concept to understand for inheritance is the parent-child relationship.
This is represented in C++ with a \textit{base} class which contains the general information that a set of child classes, called \textit{derived} classes, inherit from.
In situations where you have different variants of something which share several common required functions and data members, inheriting from one base class can not only help you abstract your code, but also help you have better code organization.

\subsection{An Example}
Let's say we are creating a geometry program which has a bunch of different shapes we want to use.
We could create a shape base class that has circles, rectangles, and triangles all inheriting from our shape parent, or \textit{base} class.
As you can imagine, some common fields we may want would be things like the size of the perimeter of the shape.
However, for the circles we may also want to add a radius field, and for the rectangles and triangles we may want to add length and width fields.

\section{The Protected Access Modifier}
So far you had only seen public and private access modifiers.
With public data members and functions, both you and any other class can access those fields.
With private data members and functions, only other member functions of your class can access those private data members and functions.
However, there is a third access modifier called \textif{protected}.
With protected access modifiers, like private you and your member functions are able to access the data member or function.
However, your derived classes now also are able to access that same field!
This basically becomes a way to make things private to only you and your derived classes, and is extremely common and important to object oriented design.

\subsection{Representing This All in C++}
In order to represent this in C++, we would first need to make the \varname{Shape} base class, then create the derived classes from the \varname{Shape} base.

This looks something like this:

\begin{Code}
class Shape{
    protected:
        double perimeter_;
    public:
        void setPerimeter(double perimeter){
            perimeter_ = perimeter;
        }
};

class Rectangle: public Shape {
    private:
        double length_;
        double width_;
    public:
        // Basic setters and getters:
        void setLength(double length){
            length_ = length;
        }
        void setWidth(double width){
            width_ = width;
        }
        double length(){
            return length_;
        }
        double width(){
            return width_;
        }
        
        // Area function:
        double area(){
            return width_ * length_;
        }
        
};

class Circle: public Shape {
    private:
        double radius_;
    public:
        void setRadius(double radius){
            radius_ = radius;
        }
        double getRadius(){
            return radius_;
        }
        // Area function:
        // Notice how we are able
        // to access the perimeter data member
        
        double area(){
            // area for circle = 
            // .5 * perimeter * radius
            return .5 * perimeter * radius_;
        }
};
            
\end{Code}
Notice how for the area function of the Circle derived class, we are able to access the \varname{perimeter\_} data member from the parent shape.
If the \varname{perimeter\_} data member of Shape had a private access modifier as opposed to a protected access modifier, we wouldn't be able to access it.

\section{Virtual Functions}

\subsection{Pure Virtual Functions}

\section{Abstract Base Classes}


\section{Practice Problems}
For this section, we will be working with a vehicle abstract base class, and be creating functions for our derived classes.

For our \varname{Vehicle} class, its \functionname{Drive} function is a pure virtual function, making it an abstract base class.
However, we do need to define \functionname{Drive} for our 3 inherited classes, our \varname{Boat}, our \varname{Car}, and our \varname{Plane}.

A function to calculate distance looks something like distance = velocity * time.

In \filename{Vehicle.h} we defined a DELTA\_TIME variable to signify the time that is supposed to pass in between each movement call.


For our \varname{Car} class, make your car move forward proportional to it's movement speed data member.
This should be multiplied with DELTA\_TIME then added to its position data member inherited from the \varname{Vehicle} class.

For the \varname{Plane} class, assume that each engine gives you an additional 100 mph of speed.
Use this to calculate the plane's velocity, then from there you can find the distance moved, and add that to its inherited position data member.

For the \varname{Boat} class, assume the boat's velocity to be 20 mph if it's a sailboat, or 50 mph if it's a motor boat, as determined by its \varname{movementType\_} data member.
Use this to determine a velocity, and again move the boat's inherited position.


Now, once you define these functions, go to your \filename{lab8.cpp} File, and fill in two functions:
\functionname{moveThisFar} and \functionname{moveThisLong}.

For \functionname{moveThisFar}, move the \varname{Vehicle} passed in using its \functionname{Drive} function until the position has changed by the specified \varname{distance}.

For \functionname{moveThisLong}, move the \varname{Vehicle} passed in using its \functionname{Drive} function until it has moved the desired amount of time.



\end{document}